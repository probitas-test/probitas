#!/usr/bin/env -S deno run -A
/**
 * Build script to generate resolved subprocess templates
 *
 * Run before `deno compile`: deno run -A scripts/build_subprocess_templates.ts
 *
 * This script resolves bare specifiers in subprocess templates and embeds
 * them as string constants for use in compiled binaries.
 *
 * @module
 */

import { resolveSubprocessTemplate } from "../src/cli/subprocess_template.ts";
import type { EmbeddedTemplates } from "../src/cli/subprocess.ts";

const templates = [
  {
    name: "list",
    url: new URL("../src/cli/_templates/list.ts", import.meta.url),
  },
  {
    name: "run",
    url: new URL("../src/cli/_templates/run.ts", import.meta.url),
  },
];

const outputs: EmbeddedTemplates = {};

for (const { name, url } of templates) {
  console.log(`Resolving template: ${name} (${url.href})`);
  try {
    const files = await resolveSubprocessTemplate(url);
    // Convert Map to Record for JSON serialization
    outputs[name] = Object.fromEntries(files);
    console.log(`  ✓ Resolved ${files.size} file(s)`);
  } catch (error) {
    console.error(`  ✗ Failed to resolve: ${error}`);
    Deno.exit(1);
  }
}

// Generate embedded templates module
const code = `// Auto-generated by scripts/build_subprocess_templates.ts
// DO NOT EDIT MANUALLY

import type { EmbeddedTemplates } from "./subprocess.ts";

export const embeddedTemplates: EmbeddedTemplates = ${
  JSON.stringify(outputs, null, 2)
};
`;

const outputPath = new URL(
  "../src/cli/_embedded_templates.ts",
  import.meta.url,
);
await Deno.writeTextFile(outputPath, code);
console.log(`\nGenerated: ${outputPath.pathname}`);
